from __future__ import annotations
import warnings
from environment.event.event import Event

class AddCatastropheEvent(Event):
    """
    Generate catastrophes
    """
    def __init__(self, risk_id, risk_start_time, risk_factor, risk_category, risk_value):
        """
        Construct a new catastrophe event

        Parameters
        ----------
        risk_id: str
            The risk identifier for all the risks generated by broker_id
        risk_start_time: int
            The time in days on which the risk brought to the market
        risk_factor: int
        risk_category: int
            The risk categories the event belongs to 
        risk_value: int
            The risk amount (<= risk_limit 10000000)
        """
        Event.__init__(self, start_time=risk_start_time, repeated=False)

        self.risk_id = risk_id
        self.risk_start_time = risk_start_time
        self.risk_factor = risk_factor
        self.risk_category = risk_category
        self.risk_value = risk_value
        
    def run(self, market, step_time):
        """
        Add catastrophe to the insruance market

        Parameters
        ----------
        market: NoReinsurance_RiskOne

            The insurance market to accept catastrophe event

        Returns
        -------
        market: NoReinsurance_RiskOne
            The updated insurance market
        """

        # Catastrophe will influce the broker claim
        claim_value = [[[] for syndicate_id in range(len(market.syndicates))] for broker_id in range(len(market.brokers))]
        for broker_id in range(len(market.brokers)):
            for syndicate_id in range(len(market.syndicates)):
                claim_value[broker_id][syndicate_id] = market.brokers[broker_id].ask_claim(syndicate_id, self.risk_category)

        # Syndicates pay claim requirements and update status, Brokers receive claims and update status
        for syndicate_id in range(len(market.syndicates)):
            for broker_id in range(len(market.brokers)):
                if market.syndicates[syndicate_id].current_capital >= claim_value[broker_id][syndicate_id]:
                    # TODO: now pay claim according to broker id, can add other mechanism in the future
                    market.syndicates[syndicate_id].pay_claim(self.risk_id, broker_id, self.risk_category, claim_value[broker_id][syndicate_id])
                    market.brokers[broker_id].receive_claim(syndicate_id, self.risk_category, claim_value[broker_id][syndicate_id])
                else:
                    market.syndicates[syndicate_id].pay_claim(broker_id, self.risk_category, claim_value[broker_id][syndicate_id])
                    market.brokers[broker_id].receive_claim(syndicate_id, self.risk_category, market.syndicates[syndicate_id].current_capital)
                    market.syndicates[syndicate_id].bankrupt()                 

        return market

    def data(self):
        """
        Get the data as a serialisable dictionary.

        Returns
        --------
        dict
        """

        return {
            self.__class__.__name__: {
                "catastrophe_id": self.risk_id,
                "catastrophe_start_time": self.risk_start_time,
                "catastrophe_factor": self.risk_factor,
                "catastrophe_category": self.risk_category,
                "catastrophe_value": self.risk_value
            }
        }

    def to_json(self):
        """
        Serialise the instance to JSON.

        Returns
        ----------
        str
        """

        return json.dumps(self.data(), indent=4)

    def save(self, filename):
        """
        Write the instance to a log file.

        Parameters
        ----------
        filename: str
            Path to file.
        """

        with open(filename, "w") as file:
            file.write(self.to_json())
